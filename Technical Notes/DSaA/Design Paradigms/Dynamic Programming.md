*just a flashy name for dividing into subproblems, then making decisions based on the outcomes of previous subproblems*

- works for subproblems that are NOT independent (different from divide & conquer).
- solve each subproblem just once.
- save the solution in a memo (memoization).


# Forward- vs Backward-chaining
Forward : bottom up (from something we know to something we want).
	- this can turn a recursive algorithm into a loop.

Backward : top to bottom to top (from goal to it's supportive needs and back).


