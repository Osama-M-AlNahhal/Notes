# Content
- General Requirements for *Web Security*
- SSL/TLS
- HTTPS
- SSH

---


# General Requirements for Web Security

## List of web threats
![[Web threats.png]]

**Web Threats can be catagorized according to:**
1. Passive vs Active Attacks
2. Threat Location:
	1. Web Server.
	2. Web Browser.
	3. Traffic on the network between the Server and Browser.

- System Security : Server security and Browser security (not in this chapter).
- Network Security : Traffic security ( in this chapter ).


**Web Security Approaches:**
1. IPSec (Network layer) : 
   - Advantages : Transparent to user, filtering ( less traffic to proccess -> less overhead).
2. SSL/TLS (Transport layer) :
   - Two Approaches:
	   a. hidden in the TCP protocol suite (transparent to user).
	   b. in packages/programs like browsers (most browsers now support TLS).
3. Application layer :
   - Advantages : security is configured to the exact needs of each application.


---

# TLS
## Key Concepts

**TLS Session:** 
	- Association between a client and a server.
	- Can have multiple ***connections*** inside it.
	- Created by the *handshake protocol*.
	- defines the parameters that will be used in all *connections* inside it, rather than having to define these parameters every time.
**TLS Connection:**
	- Transient peer-to-peer relationships.
	- Each connection is associated with only one session.


**Session States:**
- what are they? the information about the session that is stored on the server 

- when the session is first established : ( *current operating states for both read and write* ) are created.
- during the *handshake protocol* : ( *pending read and write states* ) are created.
- when the *handshake protocol* is successful : pending states become current operating states

- what information is in the *Session State?*
  1. session identifier
  2. Peer certificate : X509.v3 Certificate or NULL.
  3. Compression method/algorithm.
  4. Cipher specs : Algorithms that will be used for (encryption, hashing, etc).
  5. Master secret : 48 BYTES.
  6. Is-Resumable flag.


**Connection State:**
- what is it? information about the connection that is stored on the server.
- what information is in the *Connection State*?
	1. Server & Client Random
	2. Server write MAC secret
	3. Client write MAC secret
	4. Server write key
	5. Client write key
	6. Initialization vector
	   - used for CBC mode.
	   - initialized by the *handshake protocol*.
	   - The final ciphertext block from each record is preserved for as the IV with the following record.
	7. Sequence numbers (8 BYTES each)
	   - each party maintains separate numbers for sent and recieved messages from each connection


---

## TLS Protocols
*TLS is not a single protocol, but a layer of protocols relying on TCP/IP protocols*

**TLS Protocols:**
1. Record Protocol : provide services to higher level protocols (specially HTTP).
2. Handshake Protocol : creates a session between client and server
3. Change cipher spec Protocol : 
4. Alert Protocol : 

- *Heartbeat Protocol is defined in a different RFC than the rest of the TLS Protocols*

---

### Record Protocol
*provides two services: Confidentiality & Message Integrity*

**How it works:**
1. fragmentation: breaks upper layer messages into blocks of size <= 16kb
2. compression : (optional, must be lossless, size increase <= 1024 Byte).
3. applies a MAC : using HMAC
4. encryption :
   - symmetric encryption.
   - size increase <= 1024 Byte.
   - stream encryption: (data + MAC) encrypted.
   - block encryption: (data + MAC + Padding + length byte) encrypted.
5. add TLS Record Header : *Content type* (1 byte) + *Major version* (1 byte) + *Minor version* (1 byte) + *Compressed length* (2 bytes).

----

### Change Cipher Spec Protocol
*pending state becomes the current state*

- simplest protocol
- only 1 byte with the value of (1)

---

### Alert Protocol
*send TLS alerts to peer entity*

- 2 bytes (LEVEL, ALERT)
- levels : warning(0), fatal(1) 
	- in case of a fatal alert, the connection is dropped, and the session can't create new connections anymore.
- ALERT : a number to identify the error

---

### Handshake Protocol
*mutual authentication of server & client + negotiates and establishes the cipher suite*

- series of messages (in TLSv1.2 : 4 messages (2 round trips), in TLSv1.3 : 2 messages only).
- each message has 3 fields
	1. Type (1 byte).
	2. Length (3 bytes).
	3. Content (different sized depending on the type).

**Handshake Protocol Steps:**
![[TLS handshake protocol.png]]


***CREATION OF A SHARED MASTER KEY:***
*48 byte secret for the session*
***2 Stages:***
1. pre_master_secret is exchanged
	1. RSA
	2. Diffe-hellman
2. master_key generated by both parties


***GENERATION OF CRYPTOGRAPHIC PARAMETERS FROM THE MASTER SECRET:***
- By hashing the master secret into a long enough hash, then dividing this hash into parts, each part is for a purpose/key/initial vector.

---

### Heartbeat Protocol
*periodic signal generated by hardware or software for confirming availablitiy or for synchronization*

- runs on top of *TLS Record Protocol* (message types: heartbeat_request + heartbeat_response)
- confirms whether a client is still alive or not
- generates activity on the connection so that a firewall doesn't shut the connection down (firewalls hate idle connections).


---

***SSL/TLS Attacks:***
- Attacks on the *handshake protocol*.
- Attacks on the *record protocol* and other *application data protocols*.
- Attacks on the PKI (And X.509 certification proccess).
- Other Attacks.

---

# HTTPS
*uses port 443 which invokes SSL/TLS*

***How it works:***
1. Client sends a *Client_hello* to the Server and begins a TLS handshake.
2. after the TLS connection is created, the client sends HTTP requests as TLS data (encrypted).

**Awareness Levels:**
- *client tries to connect to an HTTP server, but it needs a SSL/TLS connection first, and to get an SSL/TLS connection u need a TCP connection. 
- a request travels down until it reaches the TCP level, and first creates a TCP connection, then SSL/TLS connection, then HTTP connection.*


**Connection Closure:**
- `Connection: close` in the HTTP header -> TCP closes then SSL/TLS then HTTP.
* some implementations require sending closure alerts before closing connections
* implementation may or may not wait for a closure alert response (if it doesn't, its called an *incomplete close*).
* *incomplete close* might mean that an Attack is happening, so client should issue a warning when this happens.


---

# SSH
*designed for remote login and X-Tunneling*

## SSH Protocol Stack
### 1 - SSH Transport Layer Protocol
   - Authenticates the server (in transport layer) + provides data confidentiality & integrity (with forward secrecy).
   - Authentication methods:
	   1. Public & Private keys
	   2. Alternative methods like (client has a local database of public keys of server) or (relying on a Certification Authority).
   - Forward secrecy: the compromise of the current session's key doesn't affect previous sessions.


***What happens in this layer?***
*messages are exchanged to create a secure tunnel, then data is sent in this tunnel, then the tunnel is closed.*


***What does the exchange look like?***
1. esablish a TCP connection.
2. Identification string exchange (1 round trip: both = *SSH_PROTOVERSION_SOFTWAREVERSION*).
3. Algorithm negotiation (1 round trip: both = *SSH_MSG_KEXINIT*).
4. Key Exchange (ends with 1 round trip: both = SSH_MSG_NEWKEYS).
5. Service Request (tunned is established and data is now encrypted).


***What does the packet look like?**
![[SSH TLP Packet format.png]]
- *everything except the packet length and the MAC get encrypted*


---

### 2 - SSH User Authentication Protocol
   - Authenticates the user using one of the following methods:
	   1. client's public key encrypted with client's private key and sent to the server.
	   2. plain-text password (it gets encrypted by the SSH Transport Layer Protocol).
	   3. Host-based: client verifies himself to the client's host, and the server verifies this host instead of verifying the client.


---

### 3 - SSH Connection Protocol 
   - multiplexes a *Tunnel* into several *Channels*.
   - assumes a Tunnel is already created.
   - either side can open a channel.
   - channels are flow controlled using a *window* mechanism.
   - Channel types: 
	   1. Session : for executing remote programs.
	   2. X11 : for running applications on a network server then displaying the results on a GUI.
	   3. Forwarded-tcpip (Remote Port Forwarding) : for allowing others to access my resources.
	   4. Direct-tcpip (Local Port Forwarding) : for accessing resources in another network.

